// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/asecurityteam/nexpose-asset-producer/pkg/domain (interfaces: Stat)

// Package assetfetcher is a generated GoMock package.
package assetfetcher

import (
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
)

// MockStat is a mock of Stat interface
type MockStat struct {
	ctrl     *gomock.Controller
	recorder *MockStatMockRecorder
}

// MockStatMockRecorder is the mock recorder for MockStat
type MockStatMockRecorder struct {
	mock *MockStat
}

// NewMockStat creates a new mock instance
func NewMockStat(ctrl *gomock.Controller) *MockStat {
	mock := &MockStat{ctrl: ctrl}
	mock.recorder = &MockStatMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockStat) EXPECT() *MockStatMockRecorder {
	return m.recorder
}

// AddTags mocks base method
func (m *MockStat) AddTags(arg0 ...string) {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "AddTags", varargs...)
}

// AddTags indicates an expected call of AddTags
func (mr *MockStatMockRecorder) AddTags(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddTags", reflect.TypeOf((*MockStat)(nil).AddTags), arg0...)
}

// Count mocks base method
func (m *MockStat) Count(arg0 string, arg1 float64, arg2 ...string) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Count", varargs...)
}

// Count indicates an expected call of Count
func (mr *MockStatMockRecorder) Count(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockStat)(nil).Count), varargs...)
}

// Gauge mocks base method
func (m *MockStat) Gauge(arg0 string, arg1 float64, arg2 ...string) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Gauge", varargs...)
}

// Gauge indicates an expected call of Gauge
func (mr *MockStatMockRecorder) Gauge(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Gauge", reflect.TypeOf((*MockStat)(nil).Gauge), varargs...)
}

// GetTags mocks base method
func (m *MockStat) GetTags() []string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTags")
	ret0, _ := ret[0].([]string)
	return ret0
}

// GetTags indicates an expected call of GetTags
func (mr *MockStatMockRecorder) GetTags() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTags", reflect.TypeOf((*MockStat)(nil).GetTags))
}

// Histogram mocks base method
func (m *MockStat) Histogram(arg0 string, arg1 float64, arg2 ...string) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Histogram", varargs...)
}

// Histogram indicates an expected call of Histogram
func (mr *MockStatMockRecorder) Histogram(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Histogram", reflect.TypeOf((*MockStat)(nil).Histogram), varargs...)
}

// Timing mocks base method
func (m *MockStat) Timing(arg0 string, arg1 time.Duration, arg2 ...string) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Timing", varargs...)
}

// Timing indicates an expected call of Timing
func (mr *MockStatMockRecorder) Timing(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Timing", reflect.TypeOf((*MockStat)(nil).Timing), varargs...)
}
